# 无符号数运算（加法和减法）
## 历史
TS中音视频pts使用33bit的无符号整数表达 0x1FFFFFFFF  
在计算时使用的是unsigned int计算，所以要保证计算完成以后依然在表示范围中需要使用以下方法

> 假设 两个pts分别为 pts_a pts_b 要求的值是pts_c    
计算和： pts_c = (pts_a + pts_b) & 0x1FFFFFFFF;  
计算差： pts_c = (pts_a - pts_b) & 0x1FFFFFFFF;  

这样可以保证得到正确的结果

按照我对这个运算的理解，实际上就是取模的运算。在C中就是%，区别是%可以应用到任何数上，而上面的 % 操作只能应用在模是2的。（实际上这里的理解有错误）

## 发展（遇到问题）  
有一次开发中自己想写一个循环buffer，刚好想到使用无符号整数加减的特性，用无符号整数来指示index的开始，和当前的index。通过两个index相减再取模来计算size  
然而在实际测试中发现这样做有问题。加法完成后取模似乎工作的很好，但是当减法做完取模后却不能得到正确的数字，所以size的计算就有问题。 

> 假设无符号数的范围是0-9 取模是6  
则在0-9中计算 (2-4)%6 = 2 实际上按照6的模应该等于4   


## 分析  
实际上不止是减法有问题其实加法也是不对的 

> 假设无符号数的范围是0-9 取模是6    
则在0-9中计算 (5 + 5)%6 = 0 (5+5 溢出结果为0) 实际上按照6的模应该等于4  

所以我分析了为什么类似0x1FFFFFFFF（0x00..0011..11这个形式）可以正常工作。原因是unsigned int的最大值2^32次方可以整除前面提到的那个数。  
所以相当于在unsigned int的范围中，分成了N个0x1FFFFFFFF的段，所以不管是加法还是减法，结果都会落到N个段中的某一个M段中。  
对上面整个进行取模后，在M中的位置与在0x1FFFFFFFF这个范围里面计算就有了相同的效果。  
所以可以用的模就是 1 2 4 8 16 。。。 2^n
## 解决循环buf的问题  
循环buf的大小就是要取得模，如果只能用2^n则显得不是很自由虽然说实话也不是不可以。。   
取一个折衷的办法，首先最大的问题是用模运算做减法是频繁有问题的，而做加法除非到达unsigned int最大表示范围则是安全的，所以用采用只有加法的模型就好了  
所以取开始 begin_i 与 size 就好了，下一个使用的buffer就是 begin_i + size , buf 溢出是 begin_i += 1 size-=1 完美~
