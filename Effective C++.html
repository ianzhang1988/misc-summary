<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="3716"/>
<h1>Effective C++</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2017/4/9 22:50</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2017/6/18 21:56</i></td></tr>
<tr><td><b>作者：</b></td><td><i>Zhang.Yang</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-size: 21px;"><b>让自己习惯C++ （1-4）</b></span></div><div><b><br/></b></div><div><b>条款1 视C++为一个语言联邦</b></div><div>C 过程式 函数式</div><div>C with class 面向对象式</div><div>Template C++ 泛型编程 还有模板元编程</div><div>STL</div><div><b><br/></b></div><div><b>条款2 尽量以const enum inline 替换#define</b></div><div><b><br/></b></div><div><b>条款3 尽可能使用const</b></div><div>尤其是在编写给其他人使用的库时，这样可能会防止一些意外的情况发生。</div><div>const char* p = greeting // non-const pointer, const data</div><div>char const* p = grerting // the same as above</div><div>char* const p = greeting // const pointer, non-const data</div><div><br/></div><div>C++中的const采用的bitwise-constness 而不是 logic-constness。他有一些缺点，比如const对象中有一个指针，指向数据。这个数据可以被操作，由于指针没有变，编译器认为这个没有问题。</div><div>如果想要在对象中实现缓存，const会组织缓存的变化，要绕过这个问题，需要使用mutable关键字。</div><div><br/></div><div>如果一个函数要求既要有const的版本又要有non-const的版本，可以将常量性转除（casting away constness），这样做可以减少代码重复。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Foo{</div><div>public:</div><div>const char&amp; operator[] (std::size_t pos) const</div><div>{</div><div> ...</div><div> ...</div><div> return text [pos];</div><div>}</div><div>char&amp; operator[] (std::size_t pos)</div><div>{</div><div> return</div><div>   const_cast&lt;char&amp;&gt;(                    // 常量性转除</div><div>     static_cast&lt;const Foo&amp;&gt;(*this)      // 把*this转为const才能调用const的operate[]函数</div><div>       [position]</div><div>   );</div><div>}</div><div>...</div><div>}</div></div><div>为什么不在const函数里面使用non-const的函数。const要求不变性，而使用可变的函数则肯能破坏不变性。就算是const对象，non-const的函数在运行时可能会做出出乎意料的事情。而如果在non-const函数中使用const，则没有问题。因为调用的non-const对象，所以调用const的函数不会改变什么，不会引起问题。</div><div><b><br/></b></div><div><b>条款4 确定对象被使用前已经被初始化</b></div><div>尽量使用成员初始化列表，避免重复初始化（成员对象Default构造初始化，和赋值）和不明确的行为。</div><div>成员初始化的顺序是声明的顺序，而不是初始化列表中的顺序。为了明了，初始化列表的顺序应与变量声明的顺序一致。</div><div>全局对象 non-local static 初始化顺序的保证问题，C++对于这种形式没有保证。绕过的方法是使用local static，通过函数返回引用，也就是单例模式。</div><div><b><span style="font-size: 21px;"><br/></span></b></div><div><span style="font-size: 21px;"><b>构造/析构/赋值 （5-12）</b></span></div><div><b><span style="font-size: 21px;"><br/></span></b></div><div><b>条款5 了解C++默默编写并调用了哪些函数</b></div><div>如果有一个空类，编译器默默的增加了构造函数，析构函数，拷贝构造函数，还有operator= 。注意，真正有调用时编译器才会真正生成，比如没有使用过=的话，编译器就不生成了。如果有其他的构造函数，编译器也不会生成默认构造函数。</div><div>operator=, 同时还要在合法的情况下生成，合法指：类声明中没有const成员，没有引用成员，因为编译器不知道怎么处理。另外如果基类的operator=被声明为private，子类也不能自动生成。</div><div><b><br/></b></div><div><b>条款6 若不想使用编译器自动生成的函数，就该明确拒绝</b></div><div>为了不让编译器自动生成，可以将相应的函数声明为private并不予实现。或者使用像Uncopyable这样的base class。</div><div><b><br/></b></div><div><b>条款7 为多态基类声明Virtual 析构函数</b></div><div>如果用一个non-virtual的基类指针记录一个子类，当delete这个指针时，C++没有规定行为。通常这样会调用父类的析构，但是不对子类进行析构。</div><div>polymorphic（多态的）base class 应该声明一个virtual 析构函数，这样的base class通常有一些virtual 函数。</div><div>当class的设计不是作为base class使用，或者不是为了多态（polymorphically），就不应该使用 virtual 析构函数。</div><div>另外，注意一些库中的类，他们如果不是为了集成或者多态设计的，就不要去继承它。比如string类。他是non-virtual的析构函数，如果集成string并使用多态，就可能导致问题。</div><div><br/></div><div><b>条款8 别让异常逃离析构函数</b></div><div>析构函数不应该吐出异常，如果析构函数中的调用可能发生异常，则析构函数自己应该捕捉异常，或者吞下异常，或者终止程序。</div><div>如果客户需要对某个异常在运行期进行捕获，则应该提供普通函数（如close，DeInit）让用户去调用并处理异常。析构函数依然可以作为双重保险吞下异常或者终止程序。</div><div><br/></div><div><b>条款9 绝不在构造函数或者析构函数中调用virtual函数</b></div><div>在构造函数或者析构中调用virtual函数，不会调用子类的析构函数，因为在那时，子类不是还没有创建出来就是已经析构掉了。所以C++的处理方案是调用基类的函数。</div><div>注：如果不能通过virtual的方法将信息向下调用，可以考虑通过构造函数初始化列表，将信息向上传递。</div><div><br/></div><div><b>条款10 令operator= 返回一个reference to *this</b></div><div>好孩子都这么做。</div><div><br/></div><div><b>条款11 在operator= 中处理“自我赋值”</b></div><div>分为两个方面 1 自我赋值安全性：你可能在=中删除了共有的资源，造成野指针 2 异常安全性：=中间发生的异常，造成野指针</div><div>三个解决方案</div><div>1 证同测试（没有异常安全性保证，但是常用容易理解）</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>if (this == &amp;other) return *this</div></div><div>2 保证异常安全性 （往往自动获得自我赋值安全性）</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>MyObject&amp; MyObject::operator=(const MyObject&amp; other)</div><div>{</div><div>     Something* pOrig = pSome;</div><div>     pSome = new Something(*other.pSome);</div><div>     delete pOrig;</div><div>     return *this</div><div>}</div></div><div>如果other是自己的话，对外没有逻辑变化，只要没有其他指向pSome的指针的话。但是可以保证当new发生问题时，pOrig指向的对象安全的保留下来</div><div>3 copy and swap 技术</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class MyObject</div><div>{</div><div>     void Swap(const MyObject&amp; other) {...// exchange}</div><div>     MyObject&amp; operator=(const MyObject&amp; other)</div><div>     {</div><div>          MyObject Temp(other);</div><div>          Swap(Temp);</div><div>          return *this;</div><div>     }</div><div>}</div></div><div><br/></div><div>大多数情况，方案1应该就足够了。总之要注意的是，保证自己给自己赋值时可以正确的执行，不会造成问题，这些自我赋值可能是不明显的。</div><div><br/></div><div><b>条款12 复制对象时勿忘其每个成分</b></div><div>如果不需要特殊行为，就让编译器去处理，他不会忘记任何一个成分。</div><div>当自己写的时候，要确保所有的变量都在里面。当有继承体系的时候，不要忘记在子类中确保正确的进行了父类的初始化（使用初始化列表 Derived：Base（Param），调用父类的=， ...; Base::operator=(Param);...）。</div><div><br/></div><div><span style="font-size: 21px;"><b>资源管理 （13-17）</b></span></div><div><br/></div><div>资源指，动态分配的内存，文件描述符，互斥锁，数据库连接，socket等等。</div><div><br/></div><div><b>条款13 以对象管理资源</b></div><div>利用对象析构的时间释放资源，防止忘记。一个例子就是只能指针。</div><div>这里主要的考虑在于，软件的发展。当一段函数很小的时候，不容易出现问题。但是随着函数扩大，修改的人员增加，就可能引入问题。例如，有人可能并没有详细的了解所有的功能，就在中间return了，导致后面的delete没有使用的时机。</div><div>注：这种对象常被称为RAII（Resource Acquisition Is Initialization， 资源获得时机便是初始化时机）</div><div><br/></div><div><b>条款14 在资源管理类中小心copying的行为</b></div><div>如果以资源管理类的方式把资源管理起来了，那么需要拷贝和赋值时要发生什么。例如自动Unlock的MutexGuard这样的对象，拷贝这个对象按照编译器默认的方式，就可能引起问题。一个Mutex，似乎不应该被拷贝。</div><div>总结来，对资源管理类来说有这样几种管理copying行为的方式</div><div>1 阻止拷贝 （条款6）</div><div>2 引用计数：对类似数据库连接一类的管理</div><div>3 复制底层资源 （深度拷贝）：比如对字符串</div><div>4 移交底层资源 ： 类似于std::auto_ptr那样，赋值后，旧的auto_ptr就为null了</div><div><br/></div><div><b>条款15 在资源管理类中提供对原始资源的访问</b></div><div>可以使用显式的方式如 get()</div><div>或者隐式的方式如 operator XXX() const {return res;}</div><div>具体如何使用，要看具体的情况。get最稳妥，但是不见得方便使用。大原则是保证不易被错误使用的原则下，保证方便的使用。</div><div><br/></div><div><b>条款16 成对使用new和delete时采用相同的形式</b></div><div>用了new[] 就要 delete[]</div><div>注意，如 typedef string addresslines[4];  string* padd = new addressline; 需要 delete[] padd;</div><div>所以 typedef 最好不要用于数组形式</div><div><br/></div><div><b>条款17 以独立语句将newed对象置入智能指针</b></div><div>原因编译器有权利去做一些调整（优化），造成不同的执行顺序，对隐式的转换一类的事情造成影响。书中的例子：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>int priority90;</div><div>void processWidget(shared_ptr&lt;Widget&gt; pw, int priority);</div><div><br/></div><div>processWidget(shared_ptr&lt;Widget&gt;(new Widget), priority());</div><div><br/></div><div>/* 编译器必须要做三件事情</div><div> - 调用 priority()</div><div> - 执行 new Widget</div><div> - 调用 shared_ptr 的构造函数</div><div><br/></div><div> C++没有规定按照如何的顺序调用，由于依赖关系， new widget必须在shared_ptr前，但是priority的调用就不一定了。如果priority调用发生在中间，发生异常的话，就没有人管new widget创建出的对象了。</div><div>*/<br/></div><div><br/></div><div>// 正确的做法</div><div>shareed_ptr&lt;Widget&gt; pw(new Widget);</div><div>processWidget(pw, priority());</div></div><div><br/></div><div><span style="font-size: 21px;"><b>设计与声明 （18-25）</b></span></div><div><br/></div><div>我的看法：</div><div>如何使用静态语言的类型系统，来促进接口、类等的正确使用。</div><div>往往提高封装性可以得到很好的效果。</div><div>设计的第一层应该是能用，第二层能正确的使用，第三层就该是能高效的使用。</div><div><br/></div><div><b>条款18 让接口容易被正确使用，不容易被误用</b></div><div>首先，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">写出接口后，要设想用户可能犯哪些错误</span>，然后应用对应的方法，减少犯错误的可能。很多时候自己写出来的接口都是想当然的，不会想还有错误使用的机会。</div><div>“促进正确使用”的办法有保持接口的一致性，保持行为的一致性（与内置类型行为兼容）。</div><div>“防止误用”的办法有，建立新类型，限制类型上的操作，束缚对象值，消除客户的管理责任</div><div>例子：使用shared_ptr ,支持定制的删除起，可以防范跨dll删除问题，因为删除器使用的是创建的dll中的。</div><div><br/></div><div><b>条款19 设计class犹如设计type</b></div><div>要像C++设计内置类型一样，设计class</div><div>需要注意的地方：</div><ul><li>新type的对象应该如何被创建和销毁？ （例如可以基于条款13）</li><li>对象的初始化和对象的赋值该有什么样的差别？ </li><li>新type的对象如果被passed by value，意味着什么？ （也就是copy构造函数会发生什么）</li><li>什么是新type的合法值？（约束条件，相关：setter 构造函数，赋值，异常）</li><li>新type需要配和某个继承图谱吗？（如果继承自其他类，就要接受其他类的设计约束，还要如果允许被继承，如何影响子类。比如哪些函数声明为virtual。）</li><li>新type需要什么样的转换？（隐式，显式；与其他的哪些type）</li><li>什么样的操作符和函数对新type是合理的？（+ - （） 等等 )</li><li>什么样的标准函数应该驳回？（条款6）</li><li>谁用新type的成员？（决定哪些函数是public的哪些是private或者protected，哪些类型是friends）</li><li>什么是新type的“未声明接口”？ （？？？？ 条款29， 效率 异常安全性 资源运用有何种保障）</li><li>新type有多么一般化？（或许需要的不是一个新type，而是一族，这样就用class Template）</li><li>真的需要一个新type吗？（如果只想做一点点的扩展，使用non member的函数，或者templates能更好地达到目标）</li></ul><div><br/></div><div><b>条款20 宁以pass-by-referrence-to-const 替换 pass-by-value</b></div><div>避免构造函数，析构函数带来的额外开销</div><div>const的主要目的是让其他人相信我不会修改传入对象里面的内容</div><div>避免切割问题（slicing problem）。例如student继承person， student stdnt；dosometh( person per ); dosomething( stdnt ); 这里stdnt就会通过copy和隐式转换创建出一个person对象进入dosomething。丢掉student的特征。</div><div>以上规则不使用与内置类型，以及stl迭代器与函数对象</div><div><br/></div><div><b>条款21 必须返回对象时，别妄想返回其reference</b></div><div>object&amp; func(); // 此时要求object有效需要静态或者堆上分配，这样造成了管理或者运用上的麻烦的话，就老老实实的返回对象。</div><div><br/></div><div><b>条款22 将成员变量声明为private</b></div><div>这里主要的问题是封装性，从代码发展的角度出发，如果使用public的成员变量，要更改他就会引起所有的客户代码发生改变。也就是说，没有封装，就无法分开实现，要修改实现时就会付出很大的代价。</div><div><br/></div><div><b>条款23 宁以non-member non-friend 替换 member 函数</b></div><div>这样做可以增加封装性，下面是例子：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>namespace BrowserStuff {</div><div>class WebBrowser {</div><div>public:</div><div>...</div><div>void clearCache();</div><div>void clearHistory();</div><div>void removeCookies();</div><div>...</div><div>}</div><div><br/></div><div>// 想要清理所有的相关数据时</div><div><br/></div><div>// 一般人的做法 </div><div>class WebBrowser {</div><div>public:</div><div>...</div><div>void clearEverything();</div><div>...</div><div>}</div><div><br/></div><div>// 更好地做法</div><div>void clearBrowser( WebBrowser &amp;wb )</div><div>{</div><div>    clearCache();</div><div>    clearHistory();</div><div>    removeCookies();</div><div>}</div><div>}</div></div><div>首先定义在这种情况下的封装性如何计算，越少代码可以看见数据，封装性越高，粗略的可以认为，越少函数访问内部数据封装性越高。所以一般人的做法中，clearEverything增加了间接对数据的访问，降低了封装性。</div><div>以上是书中的理解，感性的说，一般人的做法就是为了便利，使抽象变得复杂了。clearEverything没有增加实质的新功能。这给对象的抽象带来了负担。客户在只是单纯的要使用对象时，就要付出额外的精力理解这一类的函数。而实际上客户并不需要。non-member函数刚好就解决了这个问题，当我只看对象时，没有任何多余的东西，而当我需要遍历的功能时，他已经存在。同时这也很好的符合了<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">单一责任原则</span>。</div><div>不过当类很简单的时候，一般人的做法我觉得没有什么不好的。</div><div><br/></div><div><b>条款24 若所有参数皆需类型转换 请为此采用non-member函数</b></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Rational{</div><div>public:</div><div>    Rational(int num = 0, int dev = 1);</div><div>    const Rational operator* (const Rational&amp; rhs) const;</div><div>...</div><div>}</div><div><br/></div><div>Rational oneHalf(1,2);</div><div>// right<br/></div><div>result = oneHalf * 2; // 2 隐式转化</div><div>// wrong, compile error</div><div>result = 2 * oneHalf; // 2 是整数, 整数没有乘以Rational的形式</div><div><br/></div><div>// 需要增加</div><div>const Rational operator*( const Rational&amp; lhs, const Rational&amp; rhs );</div><div><br/></div><div>result = 2 * oneHalf; // 这样就有做隐式转换的依据了。</div><div><br/></div></div><div><br/></div><div><b>条款25 考虑写出一个不抛出异常的swap函数</b></div><div>当std::swap对类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</div><div>还可以尝试写non-member的swap函数，特化std::swap等方法。</div><div>其实，如果不是我在写给别人用的库，根本不用考虑这些问题，直接用member的swap就好了。</div><div><br/></div><div><span style="font-size: 21px;"><b>实现 （26-31）</b></span></div><div><br/></div><div><b>条款26 尽可能延后变量定义式的出现时间</b></div><div>首先，这种优化要建立在性能关键的代码段，否则意义有限。</div><div>尽量延后定义，可以让在对象构建之前的return 异常 等问题发生的时候，减少构造和析构的成本。</div><div>在循环中使用对象时，对象定义应该放在循环外定义还是循环内？ 循环外，代价是1次构造和析构，N次赋值。循环内，N次构造与N次析构，可能还有赋值。这里就要衡量赋值和构造析构的得失。</div><div><br/></div><div><b>条款27 尽量少做转型</b></div><div>尽量使用新型的转型操作符</div><div style="margin-left:40px;">const_cast, 去常量性的</div><div style="margin-left:40px;">dynamic_cast, 向下安全转型，但是要注意效率问题，见 <a href="evernote:///view/10296022/s47/b04f5db0-5196-42be-9e1b-522d9fa53fea/b04f5db0-5196-42be-9e1b-522d9fa53fea/" style="color:#69aa35">dynamic_cast 原理与效率相关</a></div><div style="margin-left:40px;">reinterpret_cast, 低级转型，实际取决于编译器，所以有不可移植性</div><div style="margin-left:40px;">static_cast, 强迫隐式转换，基本上和老的转型功能一致</div><div>尽量在设计时，避免转型，用其他方案代替。如果确实需要，尽量放在函数背后，不要直接暴露给用户。</div><div><br/></div><div>我在写ADFinder的时候，使用两个虚基类将样本分为信息部分，和样本数据操作部分，以图可以将操作分为两个部分，降低各自使用时的认知消耗。负面影响是带来了dynamic cast。按照书中要求，从设计上杜绝，我应该将两个虚基类合为一个。但是在我的场景下，这里还不能算一个效率敏感的区域。而分开的设计，确实有助于代码的理解和使用。所以在这种情况下，我应该坚持这种方式的使用。</div><div><br/></div><div><b>条款28 避免返回handles指向对象内部成分</b></div><div>handles指——指针，references，迭代器， 尽力避免返回handles，也就是说，尽量让类、让封装完成工作，增加封装性。让const的行为更像const（传出的reference可以被改变）。降低 dangling handles的可能性（野指针）。</div><div><br/></div><div><b>条款29 为“异常安全”而努力是值得的</b></div><div>异常被抛出时，要求有异常安全性的函数做到，不泄露任何资源，不破坏数据的一致性。</div><div>异常安全能做到3个等级的保证：</div><ul><li>基本承诺：保证没有数据被破坏，程序处于合法状态</li><li>强烈保证：保证程序要么成功，要么回到调用前的状态。</li><li>不抛出异常：保证函数完成承诺的功能，不抛出异常。</li></ul><div>应对资源泄漏，可以使用条款13中所述的用对象管理资源。</div><div>保证数据不被破坏，可以使用copy and swap（修改对象数据的副本，然后在一个不抛出异常的函数中将修改后的数据和原件置换），可以结合pimpl idiom（指向实现指针）。往往可以给出强烈的保证，不过缺点是copy对资源要求高，有时消耗太高以至于无法使用。</div><div>另外一个问题是，如果调用了没有异常安全的函数，则调用者就也失去了异常安全性。</div><div><br/></div><div><b>条款30 透彻了解inlining的里里外外</b></div><div>inline是由编译器，构建环境决定的，代码中的关键字只能给建议。定义于类中的函数，默认尝试inline。其他函数使用inline关键字指定。</div><div>inline并不是没有代价的，inline造成代码膨胀，导致额外的换页，降低缓存的命中率。如果在库中使用，inline函数的更改必须要客户所有的程序重新编译才能够更新，而如果不使用inline的动态链接程序，客户不需要做任何更改。</div><div>inline更多是作为一种优化的指示，在效率最敏感的地方考虑如何使用最有效果，否则事倍功半而已。</div><div><br/></div><div><b>条款31 将文件间的编译依存关系降到最低</b></div><div>分离的关键是以“声明的依赖性”代替“定义的依赖性”。</div><ul><li>如果使用object reference或者object pointer可以完成任务，就不要用object</li><li>如果能够，尽量以class声明式替换class定义式（如提前声明代替include）</li><li>为生命式和定义式提供不同的头文件</li></ul><div><br/></div><div>方法</div><ul><li>使用pimpl idiom，写出handle class，他是classImp代理。而classImp真正完成工作，使声明和实现分离。这个方法也可以用来实现不同的后端实现。</li><li>使用interface class，使用虚基类描述接口（声明），提供create返回真正的实现，真正的实现则和接口分离。同上，可以使用不同的后端实现。</li></ul><div><br/></div><div>其主要的目的是，减少编译的时候要付出的代价，另外真正的达到接口与实现的分离。但是，handle class这个方案如果只是为了这个目的而引入其代价有些太大了。这也许对超大型的项目有影响，如果整个程序的编译时间需要一个小时，那么确实很不利于开发。而现在讲究的都是微型服务，而不是超大型的程序，而且计算能力发展超过了编译能力的消耗，这种问题真的对项目有影响的可能性越来越小。很有可能是成书之时C++项目的情况与当时计算机的计算能努力促成了这个条款。</div><div>不过，他提出的这些方法依然值得学习，不过不一定是为了解决编译问题而存在。handle class 就在boost中为前端和后端实现的分离做了贡献。而interface class则是一种很好的接口与实现分离的工具。</div><div><br/></div><div><span style="font-size: 21px;"><b>继承与面向对象设计 （32-40）</b></span></div><div><br/></div><div>通过类的设计与其相应的“约定俗成”，表现继承体系想要完成的功能，指导后续继承完成“正确”的工作。</div><div><br/></div><div><b>条款32 确定你的public 继承塑造出is-a关系</b></div><div>C++的继承模型，并不一定能准确的描述在自然界或者数学里面的关系。要准确的应用继承的力量，不要用他描述不合适的关系。</div><div style="margin-left:40px;">例如企鹅是鸟，鸟能飞企鹅不能，这里的问题来自于我们对鸟的认识不对。企鹅是鸟中的鸟，只得是鸟类，是生物学概念，而飞并不在生物学中的鸟的这个抽象层级中。另一个鸟，则是日常中所见的会飞的鸟，飞自然就属于父类。</div><div style="margin-left:40px;">再有，正方形是矩形。但是C++中矩形继承正方形以后，是可能不能保证矩形特性的（矩形可以分别设置高和宽），所以用C++的继承特性描述这一个关系，就是有问题的。数学中的是，和继承中的是不一致，造成的问题。</div><div>世界上平不存在一个“适用于所有软件”的完美设计，所谓最佳设计，取决于系统希望做什么，包括现在和未来。我们要做的是，使设计实现的功能符合实际，找到语言中最合适的方式去实现，区分语言中模型和现实的区别。</div><div>C++中，类之间的关系有is-a,has-a,is-implemented-in-terms-of这三种关系。</div><div>记住public 继承意味is-a，是用于base class身上的每一件事情也一定适用于derived class，每个derived class对象同时也是一个base class</div><div><br/></div><div><b>条款33 避免遮掩继承而来的名称</b></div><div>这里讲的是C++命名的查找规则，先从小的作用域找，没有则向高一层的作用域找。这个查找只关心名字，而不在乎类型。所以如果derived class覆盖了base中的一个有重载的函数，就会隐藏起其他base中的重载函数。这不是is-a关系想要的，可以在derived class中使用using表达式，将隐藏的函数再现出来。</div><div><br/></div><div><b>条款34 区分接口继承和实现继承</b></div><div>class提供三种力量，接口，缺省实现，以及不变性。对应下面的三种声明方式，这表现一个类想要如何影响继承体系，体现了对子类的要求。</div><ul><li>纯虚函数，指定接口继承，要求子类有这个特性，但是基类不知道如何实现。</li><li>普通虚函数，指定接口继承，提供缺省实现，同样要求子类有这个特性，但是如果子类不关心的话，可以用缺省的行为。</li><li>普通函数，对这个类型来说是具有不变性的功能和特性，我不希望在子类中出现不一样的行为。</li></ul><div>其中容易出问题的是普通虚函数，需要特殊实现时，因为差错使用了缺省实现，造成麻烦。这是C++设计中没有避免的问题。人为的校正方法是，使用纯虚函数及分离的实现（指实现另一个函数，纯虚函数也是可以有实现的，两种方法都可以，一个概念）。</div><div>重点是接口，实现要灵活，不变性要保证</div><div><br/></div><div><b>条款35 考虑virtual函数以外的其他选择</b></div><div>当应对变化的部分时，除了直接使用虚函数在当前类的继承体系上做文章外，还有其他的方式可以考虑。不要只停留在virtual这个C++提供的方式上，和可以从设计上进行更多的尝试。下面给出一些方法：</div><ul><li>non-virtual interface 手法，这是Template Method模式的一种实现，使用普通函数作为接口，使用私有的virtual函数进行多态的变化。这样可以保证一部分不变性。</li><li>使用函数指针或者std::function，这是strategy模式的一个变种，通过函数调用，可以实现运行时的变化，问题是要对一些信息进行访问会减少原来类的封装性（更多的数据要公开）</li><li>传统strategy模式，相当于把virtual函数拿到另一个体系中使用，总之这是个很好很有用的模式。</li></ul><div><br/></div><div><b>条款36 绝不重新定义继承而来的non-virtual函数</b></div><div>这违背了继承is-a的属性，没有绝对好的理由就不要这么做。</div><div><br/></div><div><b>条款37 绝不重新定义继承而来的缺省参数值</b></div><div>参数值是静态绑定的，所以在动态调用时依据调用指针的类型来决定默认的参数是什么（用父类的指针调用子类的函数，默认参数使用父类的），所以为了避免混淆，不要重新定义继承来的缺省参数。</div><div><br/></div><div><b>条款38 通过复合塑造出has-a或者 is-implemented-in-terms-of</b> </div><div>对程序建模的时候，一般有两个领域。一个是应用领域——和现实世界挂钩，一般对象是一种实体或者概念，复合是has-a的关系。另一个是实现领域——是人类智慧的结晶，对象代表这一种运作方式（如list，socket），复合是is-implemented-in-terms-of, 这种方式容易和is-a关系混淆，所以不要轻易在实现领域使用继承，除非复合条款32.</div><div><br/></div><div><b>条款39 明智而审慎的使用private继承</b></div><div>Private继承意味着is-implemented-in-terms-of。他是一种实现方式，可以获得基类的实现，但是不继承接口。如果子类需要访问基类的protected成员或者重新定义基类的virtual函数，使用private是合理的。</div><div>不过这并非必要的，大多数情况可以使用组合的方式来进行实现，在原子类private领域中实现一个private class继承自原基类，使用private class的对象完成工作即可。</div><div><br/></div><div>我就根本不会考虑用这玩意儿。</div><div><br/></div><div><b>条款40 明智而审慎的使用多重继承</b></div><div>多重继承的麻烦来自于重复和不明确的问题，如果有钻石型的继承，问题尤为多（使用virtual继承可以去掉重复，但是有空间和效率的代价）</div><div>但是，他的存在是有合理性的，有时多重继承可以提供更明晰，简洁，合理，易维护的实现。不要拒绝他，要慎重的使用。工具和方法本无罪，是人的使用才带来的麻烦。</div><div><br/></div><div><span style="font-size: 21px;"><b>模板与泛型编程 （41-48）</b></span></div><div><b><span style="font-size: 21px;"><br/></span></b></div><div><b>条款41 了解隐式接口和编译器多态</b></div><div>对template参数而言，接口是隐式的，基于有效的表达式（Template是如何被使用的）。多态通过Template的具现化和函数重载发生于编译期。</div><div><br/></div><div><b>条款42 了解typename的双重意义</b></div><div>声明Template参数是，class和typename可以互换</div><div>使用关键字Template表示嵌套从属类型名称；但是不得在基类列或者成员初值列内作为基类的修饰符。（template&lt;typename T&gt; class D: public B&lt;T&gt;::Nested { public: D(int x):B&lt;T&gt;::Nested(x){} } ）</div><div style="margin-left:40px;">嵌套从属类型指的是，( 假设有 template&lt;typename T&gt;)  T::Nested 就是T内部的东西， 需要使用 typename T::Nested 的形式才能编译通过。</div><div><br/></div><div><b>条款43 学习处理模板化基类内的名称</b></div><div>在继承模板化的类时，由于模板还没有实例化，所以调用基类的函数时，编译器会认为函数不存在。这时可以在函数调用前加上this-&gt; 或者在调用前使用using来说明在基类中有这个函数。</div><div>注：在一个项目的环境中，考虑到人员能力参差不齐的问题，应该尽量少写这样的代码。</div><div><br/></div><div><b>条款44 将于参数无关的代码抽离templates</b></div><div>应对的问题是，代码膨胀。templates有时会生成很多类，其中很多函数的实现是一样的（例如函数里面没有模板相关的内容）。为了生成后的二进制代码减少重复，就有必要注意这些函数。可以考虑把他们抽到基类中，或者单独实现。</div><div>重要的意图是，在使用templates要注意到生成的二进制代码，不要造成代码膨胀。</div><div><br/></div><div><b>条款45 运用成员函数模板接受所有兼容类型</b></div><div>使用 member function templates 成员函数模板 生成 “所有可以兼容类型的函数”</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>template&lt; typename T &gt;</div><div>class B</div><div>{</div><div>public:</div><div>     template&lt; typename U &gt;</div><div>     void func( U something );</div><div>};</div></div><div>如果使用member templates用于泛化copy构造函数或者泛化赋值操作，还是需要声明正常的copy构造函数和赋值操作。</div><div><br/></div><div><b>条款46 需要类型转换时请为模板定义非成员函数</b></div><div>类中函数需要隐式类型转换的时候，定义非成员函数，以方便对二元操作的参数做类型转换。但是模板面临的问题是，简单定义在类外的函数不能正确的推导出类型来。需要定义在类型内部，并用friend声明，使函数实际上是外部函数，这样可以得到这个模板类的类型的帮助，用以推导实际的类型。</div><div><br/></div><div><b>条款47 使用traits classes 表现类型信息</b></div><div>c++为了满足面向对象（类）和基本的C的底层编程，所以类型信息不能想java一样放在Object类型里面。所以都要通过外部的方法，整体架构的方式实现。通过实现traits，用模板和一部分特化提供类型的信息。</div><div>在使用traits的时候，如果有if else test，可以使用重载的方式，即test的内容用重载的参数代替，以完成编译期的判断。</div><div><br/></div><div>这是C++的为了获得类信所使用的一种编程技术，是为了解决C++本身的缺陷发明的。这并不是多高明的事情，而是当你想要实现对类信息的获取，所需要做的调整。</div><div><br/></div><div><b>条款 48 认识Template元编程</b></div><div>TMP（Template Metaprogramming）可以将工作由运行期移往编译期，因而可以实现早期错误侦测和更高的执行效率</div><div><br/></div><div>TMP可以实现很多花哨的功能，解决一些静态编译的问题，可以在编译期实现类似于fix function的功能来，不需要分支，流水线的执行。这项技术使C++有了一些特殊的能力，可以完成更多的形式的工作。可以提高程序运行的效率。</div><div>花开两朵各表一枝。虽然TMP提供了一些好的东西，但是他本身语法上面和调试上面都很困难，所以要掌握这个能力也是需要很大代价的。而经过努力带来的那些好处，可能在其他的语言里面可以用很清晰的语法表达出来，完成更高的效率。（另外，不知道现代CPU的构架是否还能获得任何好处）</div><div>首先，不能说TMP没有用，适当的掌握还是有必要的，毕竟在使用C++的时候，他可能可以很好的解决一些问题，另外Boost库提供了大量的好东西都和TMP有些关系，为了可以更好的使用boost学习也是有必要的。TMP本身也会发展，也许高人们最后能把TMP实现出一种更好的语法来。让这种编译器的语言真正的可以用小的努力就体现出大的作用来。如果，使用TMP可以使写的程序更简单表达能力更强，那就应该用。</div><div><br/></div><div>还有一点，这个TMP的概念对于静态语言是很有意义的，对动态语言是没有意义的，这个区别需要好好体会。</div><div><br/></div><div><span style="font-size: 21px;"><b>定制new和delete （49-52）</b></span></div><div><br/></div><div><b>条款49 了解new-Handler的行为</b></div><div>set_new_handler 允许客户指定一个函数，在内存分配无法完成的时候调用。在这里面可以：</div><ul><li>让更多内存可以被使用</li><li>安装另一个new-handle——这个方法不行，换个试试</li><li>写出new-handle——抛出异常</li><li>抛出bad_alloc——一般是派生自bad_alloc的函数</li><li>调用abort或者exit</li></ul><div>Nothrow new（new (std::nothrow) Something）,是一个局限的工具，他可以保证std new 不会抛出异常返回null，但是不能保证被new的构造函数不抛出异常。</div><div><br/></div><div>使用一个mixin形式的模板类可以方便的为类型添加（通过继承）类型自己的new和handles，方法参考书中代码，这个方式叫做CRTP （curiously recurring template pattern）</div><div><br/></div><div><b>条款50 了解new和delete的合理替换时机</b></div><div>有许多理由需要自定义new和delete，如提高效能，对heap错误进行分析，记录heap使用信息。但是，在应用之前要明确系统的问题在哪里，不要急着使用这些方法。另外在自己写之前可以看看是否已经有成熟的方案，自己写的new和delete可能会有很多问题，例如new里面没有对齐，或者没有调用new-handler</div><div><br/></div><div><b>条款51 编写new和delete时需要固守常规</b></div><div>operator new 包换一个无限循环，尝试分配内存，无法满足内存要求就要调用new-handle。需要有能力处理0 byte申请。class专属版本还应该处理“比正确大小更大的申请”（基类的new要能处理子类）</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void* Base::operator new(std::size_t size) throw(std::bad_alloc)</div><div>{</div><div>     if (size != sizeof(Base) )</div><div>          return::operator new(size);</div><div>     else ...</div><div>}</div></div><div><br/></div><div>operator delete在收到null指针的时候不做任何事情，class专属版本也要处理上面说的问题。</div><div><br/></div><div><b>条款52 写了placement new 也要写 placement delete</b></div><div>placement new/delete 一般特指带一个void* 参数的new，他会把对象创建到void*参数所指的位置。</div><div>另一种placement new/delete 是指的带有其他参数（除了size）的new， 如果不声明一个形式相同的delete，那么如果在new的过程中，构造函数出现异常，C++找不到对应的delete，所以不会删除内存。</div><div>另外，如果class声明了专属的new/delete那么他们就会遮盖全局的，所以如果要普通的形式也可以正常工作，在class中也需要同时声明一般形式的new/delete</div><div><br/></div><div><span style="font-size: 21px;"><b>杂项讨论 （53-55）</b></span></div><div><br/></div><div><b>条款53 不要轻易忽视编译器警告</b></div><div><br/></div><div><b>条款54 熟悉tr1标准 也就是c++11/14</b></div><div><br/></div><div><b>条款55 熟悉boost</b></div></span>
</div></body></html> 